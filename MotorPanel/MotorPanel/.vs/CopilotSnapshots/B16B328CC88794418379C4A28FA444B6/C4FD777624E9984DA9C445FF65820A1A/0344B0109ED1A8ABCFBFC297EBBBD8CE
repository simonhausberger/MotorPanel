using Syncfusion.UI.Xaml.Gauges;
using System.IO.Ports;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Shapes;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Globalization;

namespace MotorPanel
{
    public partial class MainWindow : Window
    {
        SerialPort Serial1;
        const int baudRate = 115200;

        const byte StartByte = 0xAA;
        // new incoming layout: 1x uint32 + 9x uint16 + 2x uint8 = 24 bytes payload
        const int IncomingPayloadSize = 4 + 9 * 2 + 2; // 24
        const int PacketSize = 1 + IncomingPayloadSize; // start byte + payload = 25 bytes

        // target values are read directly from the UI when sending packets

        ObservableCollection<ChartPoint> idData = new();
        ObservableCollection<ChartPoint> iqData = new();
        ObservableCollection<ChartPoint> vdData = new();
        ObservableCollection<ChartPoint> vqData = new();
        double time = 0;
        Stopwatch stopwatch;
        double baseTime = 0; // time offset to keep X values small
        const int MaxPoints = 300;

        public MainWindow()
        {
            InitializeComponent();

            // alle verfügbaren COM-Ports abrufen und in combobox füllen
            string[] ports = SerialPort.GetPortNames();
            ComboBoxComPorts.ItemsSource = ports;
        }
        // Try to parse user-entered numbers accepting both ',' and '.' as decimal separators.
        private bool TryParseUserDouble(string text, out double value)
        {
            value = 0.0;
            if (string.IsNullOrWhiteSpace(text))
                return false;

            // 1) Try with current culture (preferred)
            if (double.TryParse(text, NumberStyles.Float, CultureInfo.CurrentCulture, out value))
                return true;

            // 2) Try invariant culture
            if (double.TryParse(text, NumberStyles.Float, CultureInfo.InvariantCulture, out value))
                return true;

            // 3) Replace comma with dot and try invariant (accept German-style input on systems expecting dot)
            string alt = text.Replace(',', '.');
            if (double.TryParse(alt, NumberStyles.Float, CultureInfo.InvariantCulture, out value))
                return true;

            // 4) Replace dot with comma and try current culture (accept dot on systems expecting comma)
            alt = text.Replace('.', ',');
            if (double.TryParse(alt, NumberStyles.Float, CultureInfo.CurrentCulture, out value))
                return true;

            return false;
        }
        public class ChartPoint
        {
            public double X { get; set; }
            public double Y { get; set; }
        }
        private async void Window_Loaded(object sender, RoutedEventArgs e)
        {
            BtnConnect.IsEnabled = true;
            BtnDisconnect.IsEnabled = false;
            txtbTargetIq.IsEnabled = false;     // weil in speed-Regelung gestartet wird

            LogEvent("motor-panel opened");
            await StartupSelfTest();

            // start stopwatch to provide accurate X axis timing (seconds)
            stopwatch = Stopwatch.StartNew();

            // Listen mit chart verbinden, damit die Datenpunkte angezeigt werden können (z. B. Id, Iq, vd, vq)
            IdSeries.ItemsSource = idData;
            IdSeries.XBindingPath = "X";
            IdSeries.YBindingPath = "Y";

            IqSeries.ItemsSource = iqData;
            IqSeries.XBindingPath = "X";
            IqSeries.YBindingPath = "Y";

            vdSeries.ItemsSource = vdData;
            vdSeries.XBindingPath = "X";
            vdSeries.YBindingPath = "Y";

            vqSeries.ItemsSource = vqData;
            vqSeries.XBindingPath = "X";
            vqSeries.YBindingPath = "Y";
        }
        // -------------- startup animation: LEDs blinken, Zeiger auf max fahren, LinearPointer animieren, alles zurücksetzen ---------------
        private async Task StartupSelfTest()
        {
            // LEDs blinken
            LedError.Fill = Brushes.Red;
            LedWarning.Fill = Brushes.Orange;
            LedEnabled.Fill = Brushes.Green;
            LedConnected.Fill = Brushes.Green;

            Ellipse[] leds = { LedError, LedWarning, LedEnabled, LedConnected };
            for (int i = 0; i < 3; i++) // 3 Blinkzyklen
            {
                foreach (var led in leds) led.Visibility = Visibility.Visible;
                await Task.Delay(200);
                foreach (var led in leds) led.Visibility = Visibility.Hidden;
                await Task.Delay(200);
            }
            // alle wieder sichtbar (oder nur Enabled/Connected?)
            LedError.Visibility = Visibility.Visible;
            LedWarning.Visibility = Visibility.Visible;
            LedEnabled.Visibility = Visibility.Visible;
            LedConnected.Visibility = Visibility.Visible;

            LedError.Fill = Brushes.WhiteSmoke;
            LedWarning.Fill = Brushes.WhiteSmoke;
            LedEnabled.Fill = Brushes.WhiteSmoke;
            LedConnected.Fill = Brushes.WhiteSmoke;

            // CircularPointer auf Max fahren
            AnimatePointer(NeedleSpeed, 4000);
            AnimatePointer(PointerSpeed, 4000);
            AnimatePointer(NeedleTorque, 2.5);
            AnimatePointer(PointerTorque, 2.5);
            AnimatePointer(NeedleIBus, 40);
            //AnimatePointer(PointerIBus, 40);
            AnimatePointer(NeedleVBus, 50);
            //AnimatePointer(PointerVBus, 50);

            await Task.Delay(500); // kurz stehen lassen

            // LinearPointer animieren
            await Task.WhenAll(
                AnimateLinearPointer(PointerPCBTemp, 80),
                AnimateLinearPointer(BarPCBTemp, 80),
                AnimateLinearPointer(PointerWindingTemp, 80),
                AnimateLinearPointer(BarWindingTemp, 80)
            );

            await Task.Delay(500);

            // Alles wieder auf 0
            AnimatePointer(NeedleSpeed, 0);
            AnimatePointer(PointerSpeed, 0);
            AnimatePointer(NeedleTorque, 0);
            AnimatePointer(PointerTorque, 0);
            AnimatePointer(NeedleIBus, 0);
            //AnimatePointer(PointerIBus, 0);
            AnimatePointer(NeedleVBus, 0);
            //AnimatePointer(PointerVBus, 0);

            await Task.WhenAll(
                AnimateLinearPointer(PointerPCBTemp, 0),
                AnimateLinearPointer(BarPCBTemp, 0),
                AnimateLinearPointer(PointerWindingTemp, 0),
                AnimateLinearPointer(BarWindingTemp, 0)
            );

            // Test-Log
            LogEvent("startup self-test done");
        }
        private async void MenuItemSelfTest_Click(object sender, RoutedEventArgs e)
        {
            LogEvent("self-test started");
            await StartupSelfTest();
            LogEvent("self-test finished");
        }
        private void AnimatePointer(CircularPointer pointer, double toValue)
        {
            DoubleAnimation anim = new DoubleAnimation();
            anim.From = pointer.Value;
            anim.To = toValue;
            anim.Duration = TimeSpan.FromMilliseconds(400);
            pointer.BeginAnimation(CircularPointer.ValueProperty, anim);
        }

        private async Task AnimateLinearPointer(LinearPointer pointer, double target, int steps = 20, int delayMs = 20)
        {
            double start = pointer.Value;
            double delta = (target - start) / steps;

            for (int i = 0; i < steps; i++)
            {
                pointer.Value += delta;
                await Task.Delay(delayMs);
            }
        }

        // -------------------------------------------------------- manage uart-connection ---------------------------------------------------
        private void BtnConnect_Click(object sender, RoutedEventArgs e)
        {
            if (ComboBoxComPorts.SelectedItem == null)
            {
                MessageBox.Show("Please select a COM-port!");
            }
            else
            {
                TryOpenSerialPort(ComboBoxComPorts.SelectedItem.ToString());
            }
        }
        private void BtnDisconnect_Click(object sender, RoutedEventArgs e)
        {
            if (Serial1 != null && Serial1.IsOpen)
            {
                // unsubscribe event handler before closing/disposing
                Serial1.DataReceived -= Serial1_DataReceived;
                Serial1.Close();
                Serial1.Dispose();
                Serial1 = null;
                LedConnected.Fill = Brushes.WhiteSmoke;
                LogEvent("serial port closed");
                BtnConnect.IsEnabled = true;
                BtnDisconnect.IsEnabled = false;
            }
        }
        private void BtnRefresh_Click(object sender, RoutedEventArgs e)
        {
            string[] ports = SerialPort.GetPortNames();
            ComboBoxComPorts.ItemsSource = ports;
        }
        void TryOpenSerialPort(string portName)
        {
            try
            {
                Serial1 = new SerialPort(portName, baudRate, Parity.None, 8, StopBits.One);
                Serial1.DataReceived += Serial1_DataReceived;
                Serial1.Open(); // Port erfolgreich geöffnet
                LogEvent("serial port opened");
                LedConnected.Fill = Brushes.Green;
                BtnConnect.IsEnabled = false;
                BtnDisconnect.IsEnabled = true;
            }
            catch (UnauthorizedAccessException)
            {
                LedConnected.Fill = Brushes.WhiteSmoke;
                MessageBox.Show($"Port {portName} is already in use!", "connection error", MessageBoxButton.OK, MessageBoxImage.Error);
                LogEvent($"port {portName} is already in use");
            }
            catch (Exception ex)
            {
                LedConnected.Fill = Brushes.WhiteSmoke;
                MessageBox.Show($"Error opening {portName}: {ex.Message}","connection error", MessageBoxButton.OK, MessageBoxImage.Error);
                LogEvent($"error opening {portName}");
            }
        }
        // ------------------------------------------------------- log-event function --------------------------------------------------------
        private void LogEvent(string message)
        {
            string timestamp = DateTime.Now.ToString("HH:mm:ss");
            string logEntry = $"[{timestamp}] {message}";

            EventLogListBox.Items.Insert(0, logEntry);
            EventLogListBox.ScrollIntoView(EventLogListBox.Items[0]);
        }

        private void TrimCollectionsIfNeeded()
        {
            // while any collection exceeds MaxPoints, remove the oldest and shift baseTime
            while (idData.Count > MaxPoints || iqData.Count > MaxPoints || vdData.Count > MaxPoints || vqData.Count > MaxPoints)
            {
                // find smallest X among oldest entries (they are synchronized by time t)
                double oldestX = double.MaxValue;
                if (idData.Count > 0) oldestX = Math.Min(oldestX, idData[0].X);
                if (iqData.Count > 0) oldestX = Math.Min(oldestX, iqData[0].X);
                if (vdData.Count > 0) oldestX = Math.Min(oldestX, vdData[0].X);
                if (vqData.Count > 0) oldestX = Math.Min(oldestX, vqData[0].X);

                if (oldestX == double.MaxValue) break;

                // remove oldest from each collection if present
                if (idData.Count > 0 && idData[0].X == oldestX) idData.RemoveAt(0);
                if (iqData.Count > 0 && iqData[0].X == oldestX) iqData.RemoveAt(0);
                if (vdData.Count > 0 && vdData[0].X == oldestX) vdData.RemoveAt(0);
                if (vqData.Count > 0 && vqData[0].X == oldestX) vqData.RemoveAt(0);

                // shift remaining points' X to keep values small
                foreach (var p in idData) p.X -= oldestX;
                foreach (var p in iqData) p.X -= oldestX;
                foreach (var p in vdData) p.X -= oldestX;
                foreach (var p in vqData) p.X -= oldestX;

                // increase baseTime by the removed offset so new t values stay continuous
                baseTime += oldestX;
            }
        }
        // ----------------------------------------------------- receiving - event handler ---------------------------------------------------
        // reihenfolge receiving: speed (unint32), torque (unint16), IBus (unint16), VBus (unint16), PCBTemp (unint16), WindingTemp (unint16), id (unint16), iq (unint16), vd (unint16), vq (unint16), error (unint8), warning (unint8)
        private void Serial1_DataReceived(object sender, SerialDataReceivedEventArgs e)
        {
            try
            {
                while (Serial1.BytesToRead >= PacketSize)
                {
                    // Prüfen ob erstes Byte Startbyte ist
                    if (Serial1.ReadByte() != StartByte)
                    {
                        continue; // solange lesen bis 0xAA gefunden wird
                    }

                    byte[] buffer = new byte[IncomingPayloadSize];
                    Serial1.Read(buffer, 0, buffer.Length);

                    // Use BeginInvoke to avoid blocking the serial thread
                    Dispatcher.BeginInvoke((Action)(() =>
                    {
                        double t = stopwatch != null ? stopwatch.Elapsed.TotalSeconds - baseTime : time;

                        // parse incoming integer-based packet
                        // offsets in buffer (little-endian expected):
                        // 0-3: uint32 speed (scaled *1000)
                        // 4-5: uint16 torque (scaled *1000)
                        // 6-7: uint16 IBus (scaled *1000)
                        // 8-9: uint16 VBus (scaled *1000)
                        // 10-11: uint16 PCBTemp (scaled *100)
                        // 12-13: uint16 WindingTemp (scaled *100)
                        // 14-15: uint16 id (scaled *1000)
                        // 16-17: uint16 iq (scaled *1000)
                        // 18-19: uint16 vd (scaled *1000)
                        // 20-21: uint16 vq (scaled *1000)
                        // 22: error (uint8)
                        // 23: warning (uint8)

                        // Ensure endianness
                        bool isLittle = BitConverter.IsLittleEndian;

                        uint rawSpeed = BitConverter.ToUInt32(buffer, 0);
                        double speed = rawSpeed / 1000.0;

                        ushort rawTorque = BitConverter.ToUInt16(buffer, 4);
                        double torque = rawTorque / 1000.0;

                        ushort rawIBus = BitConverter.ToUInt16(buffer, 6);
                        double iBus = rawIBus / 1000.0;

                        ushort rawVBus = BitConverter.ToUInt16(buffer, 8);
                        double vBus = rawVBus / 1000.0;

                        ushort rawPCBTemp = BitConverter.ToUInt16(buffer, 10);
                        double pcbTemp = rawPCBTemp / 100.0;

                        ushort rawWindingTemp = BitConverter.ToUInt16(buffer, 12);
                        double windingTemp = rawWindingTemp / 100.0;

                        ushort rawId = BitConverter.ToUInt16(buffer, 14);
                        double id = rawId / 1000.0;

                        ushort rawIq = BitConverter.ToUInt16(buffer, 16);
                        double iq = rawIq / 1000.0;

                        ushort rawVd = BitConverter.ToUInt16(buffer, 18);
                        double vd = rawVd / 1000.0;

                        ushort rawVq = BitConverter.ToUInt16(buffer, 20);
                        double vq = rawVq / 1000.0;

                        byte err = buffer[22];
                        byte warn = buffer[23];

                        // update UI elements
                        NeedleSpeed.BeginAnimation(CircularPointer.ValueProperty, null);
                        NeedleSpeed.Value = speed;

                        NeedleTorque.BeginAnimation(CircularPointer.ValueProperty, null);
                        NeedleTorque.Value = torque;

                        NeedleIBus.BeginAnimation(CircularPointer.ValueProperty, null);
                        NeedleIBus.Value = iBus;

                        NeedleVBus.BeginAnimation(CircularPointer.ValueProperty, null);
                        NeedleVBus.Value = vBus;

                        PointerPCBTemp.Value = pcbTemp;
                        BarPCBTemp.Value = pcbTemp;

                        PointerWindingTemp.Value = windingTemp;
                        BarWindingTemp.Value = windingTemp;

                        idData.Add(new ChartPoint { X = t, Y = id });
                        iqData.Add(new ChartPoint { X = t, Y = iq });
                        vdData.Add(new ChartPoint { X = t, Y = vd });
                        vqData.Add(new ChartPoint { X = t, Y = vq });

                        LedError.Fill = err == 1 ? Brushes.Red : Brushes.WhiteSmoke;
                        LedWarning.Fill = warn == 1 ? Brushes.Orange : Brushes.WhiteSmoke;

                        // Trim collections to sliding window and adjust X by removing
                        // the oldest X (baseTime) so values remain small.
                        TrimCollectionsIfNeeded();

                        // Additions to the ObservableCollection will notify the chart. Just
                        // invalidate visuals to ensure redraw.
                        CurrentChart.InvalidateVisual();
                        VoltageChart.InvalidateVisual();
                        if (stopwatch == null)
                            time += 0.1;
                    }));
                }
            }
            catch (Exception ex)
            {
                // Don't let serial exceptions crash the thread; log to UI if possible
                try
                {
                    Dispatcher.BeginInvoke((Action)(() => LogEvent($"serial receive error: {ex.Message}")));
                }
                catch
                {
                    // ignore
                }
            }
        }
        // ----------------------------------------------------- sending packets -------------------------------------------------------------
        // reihenfolge sending: TargetSpeed (unint32), TargetIq (unint16), ControlMode (unint8), EnableMotor (unint8), StartStop (unint8), Direction (unint8), FOC/Block (unint8), Sensored/Sensorless (unint8)
        // now sending unsigned 32-bit integers (4 bytes each). Numeric values scaled by 1000. Booleans: 0 = false, 1 = true.
        private void SendControlPacket()
        {
            if (Serial1 == null || !Serial1.IsOpen)
                return;

            // parse and scale numeric entries (factor 1000)
            double parsedSpeed = 0.0;
            double parsedIq = 0.0;
            TryParseUserDouble(txtbTargetSpeed.Text, out parsedSpeed);
            TryParseUserDouble(txtbTargetIq.Text, out parsedIq);

            // scale and clamp to unsigned 32-bit range
            double scaledSpeed = Math.Round(parsedSpeed * 1000.0);  // mal 1000 da in uint gesendet wird
            if (scaledSpeed < 0) scaledSpeed = 0;
            if (scaledSpeed > uint.MaxValue) scaledSpeed = uint.MaxValue;
            uint targetSpeedInt = (uint)scaledSpeed;

            double scaledIq = Math.Round(parsedIq * 1000.0);
            if (scaledIq < 0) scaledIq = 0;
            if (scaledIq > uint.MaxValue) scaledIq = uint.MaxValue;
            uint targetIqInt = (uint)scaledIq;

            // control flags as unsigned ints: keep previous semantic (checked = torque -> 0, speed -> 1)
            uint controlMode = SwitchControlMode.IsChecked == true ? 0u : 1u;
            uint enableMotor = SwitchEnableMotor.IsChecked == true ? 1u : 0u;
            uint startStop = SwitchStartStop.IsChecked == true ? 1u : 0u;
            uint direction = SwitchDirection.IsChecked == true ? 1u : 0u;
            uint focBlock = SwitchBlockFoc.IsChecked == true ? 1u : 0u;
            uint sensorMode = SwitchSensor.IsChecked == true ? 1u : 0u;

            // Build packet according to new spec:
            // StartByte (1)
            // TargetSpeed: uint32 (4 bytes) scaled *1000
            // TargetIq: uint16 (2 bytes) scaled *1000
            // ControlMode: byte
            // EnableMotor: byte
            // StartStop: byte
            // Direction: byte
            // FOC/Block: byte
            // Sensored/Sensorless: byte

            byte[] packet = new byte[1 + 4 + 2 + 6]; // 1 + 4 + 2 + 6 = 13
            packet[0] = StartByte;

            int idx = 1;

            // TargetSpeed uint32
            byte[] speedBytes = BitConverter.GetBytes(targetSpeedInt);
            if (!BitConverter.IsLittleEndian)
                Array.Reverse(speedBytes);
            Array.Copy(speedBytes, 0, packet, idx, 4);
            idx += 4;

            // TargetIq uint16 (clamp to ushort)
            ushort targetIqU16 = (ushort)Math.Min(targetIqInt, ushort.MaxValue);
            byte[] iqBytes = BitConverter.GetBytes(targetIqU16);
            if (!BitConverter.IsLittleEndian)
                Array.Reverse(iqBytes);
            Array.Copy(iqBytes, 0, packet, idx, 2);
            idx += 2;

            // flags as single bytes
            packet[idx++] = (byte)controlMode;
            packet[idx++] = (byte)enableMotor;
            packet[idx++] = (byte)startStop;
            packet[idx++] = (byte)direction;
            packet[idx++] = (byte)focBlock;
            packet[idx++] = (byte)sensorMode;

            try
            {
                lock (Serial1)
                {
                    Serial1.Write(packet, 0, packet.Length);
                }

                LogEvent($"control packet sent ({packet.Length} bytes)");
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error sending packet to µC: {ex.Message}", "serial error", MessageBoxButton.OK, MessageBoxImage.Error);
                LogEvent($"control packet send error: {ex.Message}");
            }
        }

        // -------------------------------------------------------- buttons ------------------------------------------------------------------
        private void BtnApplyTarget_Click(object sender, RoutedEventArgs e)
        {
            // values are read directly from the UI inside SendControlPacket
            SendControlPacket();
        }

        private void SwitchControlMode_Click(object sender, RoutedEventArgs e)
        {
            if(SwitchControlMode.IsChecked == true) // Iq-Regelung
            {
                LogEvent("switched to torque control (just in FOC available)");
                SwitchBlockFoc.IsChecked = true;   // hier keine Blockkommutierung möglich
                SwitchBlockFoc.IsEnabled = false;
                txtbTargetSpeed.IsEnabled = false;
                txtbTargetIq.IsEnabled = true;

                
            }
            else     // speed-Regelung
            {
                LogEvent("switched to speed control (FOC keeps activated)");
                SwitchBlockFoc.IsEnabled = true;
                txtbTargetSpeed.IsEnabled = true;
                txtbTargetIq.IsEnabled = false;

                
            }

            SendControlPacket();
        }

        private void SwitchEnableMotor_Click(object sender, RoutedEventArgs e)
        {
            if(SwitchEnableMotor.IsChecked == true)
            {
                LogEvent("motor enabled");
                LedEnabled.Fill = Brushes.Green;
            }
            else
            {
                LogEvent("motor disabled");
                LedEnabled.Fill = Brushes.WhiteSmoke;
            }

            SendControlPacket();
        }

        private void SwitchStartStop_Click(object sender, RoutedEventArgs e)
        {
            if (SwitchStartStop.IsChecked == true)            
            {
                LogEvent("motor started");
            }
            else
            {
                LogEvent("motor stopped");
            }

            SendControlPacket();
        }

        private void SwitchDirection_Click(object sender, RoutedEventArgs e)
        {
            if (SwitchDirection.IsChecked == true)
            {
                LogEvent("direction: right");
            }
            else
            {
                LogEvent("direction: left");
            }

            SendControlPacket();
        }

        private void SwitchBlockFoc_Click(object sender, RoutedEventArgs e)
        {
            if (SwitchBlockFoc.IsChecked == true)
            {
                LogEvent("FOC activated");
            }
            else
            {
                LogEvent("block-commutation activated");
            }

            SendControlPacket();
        }

        private void SwitchSensor_Click(object sender, RoutedEventArgs e)
        {
            if(SwitchSensor.IsChecked == true) 
            {
                LogEvent("sensorless mode activated");
            }
            else
            {
                LogEvent("sensored mode activated");
            }

            SendControlPacket();
        }

        private void txtbTargetSpeed_TextChanged(object sender, TextChangedEventArgs e)
        {
            if (string.IsNullOrWhiteSpace(txtbTargetSpeed.Text))
            {
                AnimatePointer(PointerSpeed, 0);
                return;
            }

            if (TryParseUserDouble(txtbTargetSpeed.Text, out double speed))
            {
                if (speed >= 0 && speed <= 4000)
                {
                    // set reference pointer directly so it stays at the entered target
                    PointerSpeed.BeginAnimation(CircularPointer.ValueProperty, null);
                    PointerSpeed.Value = speed;
                }
                else
                {
                    MessageBox.Show("The value must be between 0 and 4000.", "Warning", MessageBoxButton.OK, MessageBoxImage.Warning);
                }
            }
            else
            {
                MessageBox.Show("Please enter a valid number.", "Warning", MessageBoxButton.OK, MessageBoxImage.Warning);
            }
        }

        private void txtbTargetIq_TextChanged(object sender, TextChangedEventArgs e)
        {
            if (string.IsNullOrWhiteSpace(txtbTargetIq.Text))
            {
                AnimatePointer(PointerTorque, 0);
                return;
            }

            if (TryParseUserDouble(txtbTargetIq.Text, out double iq))
            {
                if (iq >= 0 && iq <= 2.5)
                {
                    AnimatePointer(PointerTorque, iq);
                }
                else
                {
                    MessageBox.Show("The value must be between 0 and 5.", "Warning", MessageBoxButton.OK, MessageBoxImage.Warning);
                }
            }
            else
            {
                MessageBox.Show("Please enter a valid number.", "Warning", MessageBoxButton.OK, MessageBoxImage.Warning);
            }
        }

        private void info_Click(object sender, RoutedEventArgs e)
        {
            MessageBox.Show("info text", "info", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        private void help_Click(object sender, RoutedEventArgs e)
        {
            MessageBox.Show("help text", "help", MessageBoxButton.OK, MessageBoxImage.Information);
        }
    }
}
